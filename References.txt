References.txt
			"""
02
Program: 7_1.py
03
Author: kkasp
04
Function drawCircle
05
-Expect Turtle object, coordinates of the circle's center point and
06
circle's radius as arguments
07
-Function draws circle
08
-Draw circle's circumference by turning 3 degrees and moving a given
09
distance, 120 times.
10
-Calculate the distance moved with formula 2.0 * 3.14 * radius /120
11
 
13

from pyglet.gl import *
from math import pi, sin, cos

window = pyglet.window.Window(width=400, height=400)

glClearColor(0.2, 0.4, 0.5, 1.0)

def circle(x, y, radius):
    """
    We want a pixel perfect circle. To get one,
    we have to approximate it densely with triangles.
    Each triangle thinner than a pixel is enough
    to do it. Sin and cosine are calculated once
    and then used repeatedly to rotate the vector.
    I dropped 10 iterations intentionally for fun.
    """
    iterations = int(2*radius*pi)
    s = sin(2*pi / iterations)
    c = cos(2*pi / iterations)

    dx, dy = radius, 0

    glBegin(GL_TRIANGLE_FAN)
    glVertex2f(x, y)
    for i in range(iterations+1 - 10):
        glVertex2f(x+dx, y+dy)
        dx, dy = (dx*c - dy*s), (dy*c + dx*s)
    glEnd()

@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)

    glColor3f(0, 0, 0)

    circle(200, 200, 100)

    glColor3f(1, 1, 1)

    circle(250, 250, 10)

pyglet.app.run()

# def drawFingerCircles():
		# self.positions = []
		# step = 2 * math.pi / nr_elements
		# if clock_wise:
		# 	step *= -1
		# for i in range(nr_elements):
		# 	if angles is None:
		# 		phi = start + i * step

		# 	else:
		# 		phi = angles[i]

		# 	x = relative_center[0] + (radius * math.cos(phi)) 
		# 	y = relative_center[1] + (radius * math.sin(phi))
		# 	self.positions.append([x, y])
		
import serial
ser = serial.Serial('/dev/tty.ACM0', 9600) # args: path/to/ard, sampling rate  tty.ACM0
